snippet i
	IO.inspect(${1})
snippet p
	IO.puts(${1})
snippet #
	#{${1}}
snippet >
	|> ${1}
snippet &
	&(${1:&1}${2})
snippet if
	if ${1:true} do
		${2}
	end
snippet ife
	if ${1:true} do
		${2}
	else
		${3}
	end
snippet un
	unless ${1:false} do
		${2}
	end
snippet case
	case ${1} do
		_ -> "fallback"
	end
snippet cond
	cond do
		${1}
	end
snippet fn
	fn ${1}-> ${2} end
snippet defm "Define module"
	defmodule ${1:`expand("%:p")->tr('\/', '..')->matchstr('\%(lib\|test\)\.\zs.*\ze\.exs\?$')->substitute('\%(^\|_\|\.\zs\)\(.\)', '\u\1', 'g')`} do
		${2}
	end
snippet deftm "Define Test module"
	defmodule ${1:`expand("%:p")->tr('\/', '..')->matchstr('\%(lib\|test\)\.\zs.*\ze\.exs\?$')->substitute('\%(^\|_\|\.\zs\)\(.\)', '\u\1', 'g')`} do
		use ExUnit.Case, async: true
		${2}
	end
snippet def
	def ${1:func_name} do
		${2::ok}
	end
snippet defp
	defp ${1:func_name} do
		${2::ok}
	end
snippet map
	Enum.map(${1})
snippet smap
	Stream.map(${1})
snippet red
	Enum.reduce(${1})
snippet sred
	Stream.reduce(${1})
snippet take
	Enum.take(${1})
snippet doc
	@doc ~S"""
	${1}
	"""
snippet mdoc
	@moduledoc ~S"""
	${1}
	"""
